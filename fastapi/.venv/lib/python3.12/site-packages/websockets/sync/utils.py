from __future__ import annotations

import time
<<<<<<< HEAD
from typing import Optional
=======
>>>>>>> origin/main


__all__ = ["Deadline"]


class Deadline:
    """
    Manage timeouts across multiple steps.

    Args:
        timeout: Time available in seconds or :obj:`None` if there is no limit.

    """

<<<<<<< HEAD
    def __init__(self, timeout: Optional[float]) -> None:
        self.deadline: Optional[float]
=======
    def __init__(self, timeout: float | None) -> None:
        self.deadline: float | None
>>>>>>> origin/main
        if timeout is None:
            self.deadline = None
        else:
            self.deadline = time.monotonic() + timeout

<<<<<<< HEAD
    def timeout(self, *, raise_if_elapsed: bool = True) -> Optional[float]:
=======
    def timeout(self, *, raise_if_elapsed: bool = True) -> float | None:
>>>>>>> origin/main
        """
        Calculate a timeout from a deadline.

        Args:
<<<<<<< HEAD
            raise_if_elapsed (bool): Whether to raise :exc:`TimeoutError`
=======
            raise_if_elapsed: Whether to raise :exc:`TimeoutError`
>>>>>>> origin/main
                if the deadline lapsed.

        Raises:
            TimeoutError: If the deadline lapsed.

        Returns:
            Time left in seconds or :obj:`None` if there is no limit.

        """
        if self.deadline is None:
            return None
        timeout = self.deadline - time.monotonic()
        if raise_if_elapsed and timeout <= 0:
            raise TimeoutError("timed out")
        return timeout
